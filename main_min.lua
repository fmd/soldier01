function dump(o)if type(o)=='table'then local s='{ 'for b,v in pairs(o)do if type(b)~='number'then b='"'..b..'"'end;s=s..'['..b..'] = '..dump(v)..','end;return s..'} 'else return tostring(o)end end;raw_sprite_store="floor=181|void=255|select=46|choose=30|bad=15|vault=31"raw_map_store="actor_player=17,1,33,49|actor_enemy=208,192,224,240|door_multidoor=88,89|door_keydoor=104,105|item_ration=180|item_keycard=185|item_equip=133|object_trapdoor=176|object_relay=132|object_multikey=136"raw_animations="player=17,18,19,18,21,23,22,20:1,2,3,2,5,7,6,4:33,34,35,34,37,39,38,36:49,50,51,50,53,55,55,52:8,9,10,11:12,13:25,24,25,24|enemy=208,209,210,209,210,211,211,1:192,193,194,193,194,195,195,1:224,225,226,225,226,227,227,1:240,241,242,241,242,243,243,1:196,197,198,199:230,231:41,40,41,40:228,229|door=67,129:68,130|keydoor=104,160:105,161|multidoor=88,144:89,145|multikey=136,137|blood_prints=26,27,28,29|trapdoor=176,177|relay=132,186|ration=180|equip=133|keycard=185"raw_global_objects="actor=nil|object=nil|relay=nil|door=nil|trapdoor=nil|prints=nil|item=nil|multikey=nil"function unmarshal_store(e)local g={}elements=split(e,"|")for j in all(elements)do split_elements=split(j,"=")key,value=split_elements[1],split_elements[2]if split_elements[2]=="nil"then g[key]={}else split_values=split(value,":")g[key]={}for s in all(split_values)do split_commas=split(s)local k={}if#split_commas==1 then add(k,split_commas[1])else add(k,split_commas)end;if#k==1 then k=k[1]end;add(g[key],k)end;if#g[key]==1 then g[key]=g[key][1]end end end;return g end;sprite_store=unmarshal_store(raw_sprite_store)map_store=unmarshal_store(raw_map_store)animations=unmarshal_store(raw_animations)enemy_variants={player={{"player",{5,5}}},enemy={{"clockwise",{5,13}},{"line",{5,2}},{"still",{5,5}},{"cc",{5,6}}}}levels={{0,0,36,30}}level_items={{"diving_suit","gloves"}}level_keydoors={{2,1,1,2,2}}level_multidoors={{{{11,18}},{{23,24},{25,27}}}}level_enemy_variants={{2,2,3,3,3,3,2,4,3,2,1,4,1,1,3,2,1,2,2,3,3,3,2,1,3,1,3,1,1}}turn,chunk,frame,biframe,last_frame=0,0,1,1,0;global_time,turn_start=nil,nil;input_act,input_dir,input_down=0,0,{false,false,false,false,false,false}last_camera_pos={x=0,y=0}queued_input=nil;level_loaded=false;current_level=0;game_speed=2.5;local n={}local q={}local r={}local u={}local w={}local x={}local y={}function reset_global_objects()global_objects=unmarshal_store(raw_global_objects)inventory={}global_object_counts={}queued_input=nil end;mset_restore={}checkpoint={active_relays={},inventory={keycard_level=0,gloves=false,diving_suit=false,socom=false}}function _init()load_level(1)end;function _update60()if not level_loaded or not player then return end;local z=take_input()if z and z[1]>1 and player.life<=0 then load_level(current_level)return end;if z and not queued_input then queued_input=z end;update_frame()if turn_start then if chunk>999 then end_turn()end;return end;if player.life>0 then if queued_input and queued_input[1]>4 then queued_input[1]=queued_input[1]-3 end;player.input_act=queued_input;queued_input=nil;if not player.input_act then return end;player:determine_act()if player:act_pos()==player.pos and player.input_act[1]==1 then return end;start_turn()player.input_act=nil end;if not turn_start and chunk>499 then start_turn()end end;function _draw()cls()if not level_loaded or not player then return end;local p=to_pixel(player.pos)buffer=make_vec2d(0,0)if p~=last_camera_pos then buffer=p-last_camera_pos;buffer.x=-flr(buffer.x/1.5)buffer.y=-flr(buffer.y/1.5)end;camera(p.x+buffer.x-56,p.y+buffer.y-56)last_camera_pos=p+buffer;draw_map()draw_set(global_objects.object)draw_set(global_objects.actor)draw_set({player})local v=make_vec2d(player.pos.x,player.pos.y)local A=sprite_store.select;local B=false;local C=player.act;if C and C[1]==1 then local p=v+dir_to_vec(C[2])if p:is_vault_gate()and inventory.gloves then p=p+dir_to_vec(C[2])end;if p:is_wall()then B=true end;if not B then v=p end end;if queued_input and queued_input[1]==1 then local p=v+dir_to_vec(queued_input[2])if p:is_vault_gate()and inventory.gloves then p=p+dir_to_vec(queued_input[2])end;if p:is_wall()then B=true end;if not B then v=p end end;local D=to_pixel(v)B=false;if v~=player.pos then zspr(A,D.x,D.y)end;if input_act==1 and not queued_input then A=sprite_store.select;local E=false;local p=dir_to_vec(input_dir)+v;if p:is_wall()then B=true end;if p:is_vault_gate()and inventory.gloves then B=false;E=true end;local D=to_pixel(p)A=sprite_store.choose;if B then A=sprite_store.bad end;if E then A=sprite_store.vault end;zspr(A,D.x,D.y)end;if input_act==5 then zspr(57,p.x+4,p.y-7,1)end;if input_act==6 then zspr(56,p.x+4,p.y-7,1)end;camera(0,0)draw_bar("life",player.life,player.max_life,3,2,0)if player:in_water()then draw_bar("o2",player.o2,player.max_o2,12,1,1)end;if inventory.keycard_level>0 then draw_keycard_ui()end;if player.blood_prints>0 then draw_blood_ui()end;rectcolor=3;if turn_start~=nil then rectcolor=5 end;rect(0,0,127,127,rectcolor)end;function load_level(l)level_loaded=false;reset_global_objects()player=nil;inventory=copymt(checkpoint.inventory)global_time=time()restore_msets(current_level)current_level=l;for F=0,levels[l][4]-1,1 do for G=0,levels[l][3]-1,1 do local v=make_vec2d(G,F)local t=lmapget(v,l)local o=get_tile_pattern(t)if o then add(mset_restore,{v,t})lmapset(v,l,extract_object_from_map(v,o))end end end;c=checkpoint.current_relay;if c then local a=make_actor(make_vec2d(c.x,c.y),{"actor","player",2})add(global_objects.actor,a)player=a end;level_loaded=true end;function extract_object_from_map(H,I)local J={}if I[1]=="actor"then if I[2]~="player"or not checkpoint.current_relay then J=make_actor(H,I)add(global_objects.actor,J)if I[2]=="player"then player=J end end else J=make_object(H,I)if I[1]=="object"then add(global_objects[I[2]],J)else add(global_objects[I[1]],J)end;if I[2]=="trapdoor"or I[1]=="door"then return sprite_store.void end end;return sprite_store.floor end;function make_object(H,I,K)local t={pattern=I[1],subpattern=I[2],pos=make_vec2d(H.x,H.y),facing=I[3]or 1}mt=copymt(q)mk="make_"..t.subpattern;if not global_object_counts[t.subpattern]then global_object_counts[t.subpattern]=0 end;global_object_counts[t.subpattern]=global_object_counts[t.subpattern]+1;mmm=u[mk]if not K then mmm(t,mt)add(global_objects.object,t)end;setmetatable(t,mt)return t end;function make_actor(H,I)local t=make_object(H,I,true)t.life,t.max_life=1,1;t.aquatic=false;t.variant=level_enemy_variants[current_level][global_object_counts[t.subpattern]]t.blood_prints,t.stunned_turns=0,0;t.laser={frames=0,target=make_vec2d(0,0),dir=0,tiles={}}t.frames={n=0,pattern=""}t.act={0,0}local mt=copymt(n)if I[2]=="player"then u.make_player(t,mt)end;setmetatable(t,mt)return t end;function u.make_player(t,mt)t.aquatic=true;t.variant=1;t.life,t.max_life=3,3;local L=3;if inventory.diving_suit then L=6 end;t.o2,t.max_o2=L,L;function mt.__index.determine_act(self)self.act=copymt(self.input_act)self:turn_to_face_act()end;function mt.__index.act_pos(self)local M=x.act_pos(self)if not inventory.gloves or not(self.act[2]>0)then return M end;local d=dir_to_vec(self.act[2])if(d+self.pos):is_vault_gate()and self.act[1]==1 then local N=d+d+self.pos;if N:is_wall()then return make_vec2d(self.pos.x,self.pos.y)end;return N end;return M end end;function make_item(t,mt)function mt.__index.activate(self)if self.pos==player.pos then self:pick_up()del(global_objects.item,self)del(global_objects.object,self)end end;function mt.__index.pick_up(self)end;function mt.__index.draw(self)local p=to_pixel(self.pos)local O=abs(biframe-4)-3;if not turn_start then O=3 end;zspr(self:sprite(),p.x,p.y-O)end end;function u.make_door(t,mt)t.solid=1;function mt.__index.draw(self)end;function mt.__index.draw_above(self)local p=to_pixel(self.pos)zspr(animations[self.subpattern][self.facing][1-self.solid+1],p.x,p.y)end end;function u.make_multidoor(t,mt)t.scanner_positions=level_multidoors[current_level][global_object_counts["multidoor"]]u.make_door(t,mt)function mt.__index.activate(self)if self.solid==0 then return end;local P=true;for p in all(self.scanner_positions)do local s=make_vec2d(p[1],p[2])local o=s:objects_on_here(nil,"multikey")[1]if not o or o.activated~=1 then P=false end end;if P then self.solid=0;sfx(16)end end end;function u.make_keydoor(t,mt)t.keycard_level=level_keydoors[current_level][global_object_counts["keydoor"]]u.make_door(t,mt)function mt.__index.activate(self)if self.solid==0 then return end;if self.pos:is_adjacent(player.pos)then if inventory.keycard_level>=self.keycard_level then sfx(16)self.solid=0 else sfx(17)end end end end;function u.make_relay(t,mt)t.active=0;for p in all(checkpoint.active_relays)do if t.pos==p then t.active=1 end end;local c=checkpoint.current_relay;function mt.__index.activate(self)if player.life<=0 or player.pos~=self.pos or self.active~=0 then return end;sfx(18)self.active=1;v=make_vec2d(self.pos.x,self.pos.y)del(checkpoint.active_relays,v)add(checkpoint.active_relays,v)player.life=player.max_life;checkpoint.inventory=copymt(inventory)checkpoint.current_relay=copymt(self.pos)end;function mt.__index.sprite(self)return animations.relay[self.active+1]end end;function u.make_keycard(t,mt)make_item(t,mt)function mt.__index.pick_up(self)if player.life<=0 then return end;inventory.keycard_level=inventory.keycard_level+1;sfx(14)end end;function u.make_ration(t,mt)make_item(t,mt)function mt.__index.pick_up(self)if player.life<=0 then return end;player.life=player.max_life;sfx(15)end end;function u.make_equip(t,mt)make_item(t,mt)t.equip=level_items[current_level][global_object_counts["equip"]]function mt.__index.pick_up(self)inventory[t.equip]=true;if t.equip=="diving_suit"then player.max_o2=6;player.o2=6 end;sfx(21)end end;function u.make_multikey(t,mt)t.activated=0;function mt.__index.draw(self)local p=to_pixel(self.pos)zspr(animations[self.subpattern][self.activated+1],p.x,p.y)end;function mt.__index.activate(self)local Q=self.pos:actors_on_here()if not Q then return end;for a in all(Q)do if a.life>0 and a~=player then self.activated=1-self.activated;sfx(20-self.activated)return end end end end;function u.make_trapdoor(t,mt)t.timer=false;function mt.__index.activate(self)if self.timer then self.timer=false;self.facing=2;sfx(13)end;local Q=self.pos:actors_on_here()if not Q then return end;for a in all(Q)do if a.life>-2 then if self.facing==1 then sfx(11)self.timer=true;return end;sfx(5)a:fall()end end end end;function get_tile_pattern(R)for pattern,S in pairs(map_store)do local p=split(pattern,"_")if not check_type(S,"table")then if S==R then return{p[1],p[2],1}end else for f,i in pairs(S)do if i==R then return{p[1],p[2],f}end end end end;return nil end;function restore_msets(l)for m in all(mset_restore)do mset(m[1].x+levels[l][1],m[1].y+levels[l][2],m[2])end;mset_restore={}end;function lmapget(v,l)l=l or current_level;return mget(v.x+levels[l][1],v.y+levels[l][2])end;function lmapset(v,l,R)mset(v.x+levels[l][1],v.y+levels[l][2],R)end;function start_turn()for T in all(global_objects.actor)do if T.life>0 then T:determine_act()T:pickup_prints()if T.blood_prints>=1 then T:place_new_prints("blood_prints")end end end;local U=true;while U do U=false;for T in all(global_objects.actor)do if T~=player and T.life>0 then U=T:do_avoidance()or U end end end;turn=turn+1;global_time=time()turn_start=time()update_frame()end;function end_turn()turn_start=nil;global_time=time()if player.blood_prints>=1 then player:redirect_existing_prints("blood_prints")end;for a in all(global_objects.actor)do a:tick_oxygen()if a.blood_prints>=1 then a.blood_prints=a.blood_prints-1 end;if a~=player then a:attempt_act(1)end end;player:attempt_melee()player:attempt_act(1)for a in all(global_objects.actor)do a:attempt_act(2)a.act={0,0}end;for o in all(global_objects.object)do o:activate()end end;function btnpress(i)if i>4 then input_act=i;if input_dir==0 then input_dir=player.facing end else input_dir=i;if input_act<5 then input_act=1 end end end;function take_input()local V={btn(2),btn(1),btn(3),btn(0),btn(4),btn(5)}for i=1,6 do if V[i]and not input_down[i]then input_down[i]=true;btnpress(i)elseif not V[i]and input_down[i]then input_down[i]=false;temp_act=input_act;if input_act==i or input_dir==i and input_act==1 then input_act=0;return{temp_act,input_dir}end end end;return nil end;function cut_chunk(c,v,m)return mid(1,flr(c/v)+1,m)end;function update_frame()chunk=flr((time()-global_time)*1000*game_speed)frame=cut_chunk(chunk,250,4)biframe=cut_chunk(chunk,125,8)if frame~=last_frame and chunk>250 then roll_frame()last_frame=frame end end;function roll_frame()for a in all(global_objects.actor)do if a.laser.frames>0 then a.laser.frames=a.laser.frames-1 end;if a.frames.n>0 then a.frames.n=a.frames.n-1 end end end;function zspr(W,X,Y,Z,_,h,ssw,ssh)local v=n_to_vec(W)_=_ or 1;h=h or 1;ssw=ssw or 8;ssh=ssh or 8;Z=Z or 2;sw,sh=ssw*_,ssh*h;dw,dh=sw*Z,sh*Z;sspr(v.x,v.y,sw,sh,X,Y,dw,dh)end;function draw_set(a0)for o in all(a0)do o:draw_below()end;for o in all(a0)do o:draw()end;for o in all(a0)do o:draw_above()end end;function draw_map()for F=levels[current_level][2],levels[current_level][4]-1,1 do if F<player.pos.y+5 and F>player.pos.y-5 then for G=levels[current_level][1],levels[current_level][3]-1,1 do if G>player.pos.x-5 and G<player.pos.x+5 then local v=make_vec2d(G,F)local a1=to_pixel(v)local R=lmapget(v)if R>0 then zspr(R,a1.x,a1.y)end end end end end end;function draw_bar(a2,a3,a4,a5,a6,a7)barp=a7*10;rect(2,2+barp,a4*5+3,7+barp,6)rectfill(3,3+barp,a4*5+2,6+barp,a6)if a3>0 then rectfill(3,3+barp,a3*5+2,6+barp,a5)end;print(a2,4,6+barp,7)end;function draw_blood_ui()spr(143,112,3)print(player.blood_prints,121,4,7)end;function draw_keycard_ui()spr(185,85,3)print("lv."..inventory.keycard_level,93,4,7)end;function default_sprite(a8,a9)s=animations[a8]if not check_type(s,"table")then return s end;if a9<=0 or not a9 then return s[1]end;if not check_type(s[a9],"table")then return s[a9]end;return s[a9][1]end;function w.sprite(self)return default_sprite(self.subpattern,self.facing)end;function w.draw(self)local p=to_pixel(self.pos)zspr(self:sprite(),p.x,p.y)end;function w.draw_below(self)end;function w.draw_above(self)end;function w.activate(self)end;q.__index=w;function x.act_pos(self)local a=self.act[1]local d=self.act[2]if d==0 then return self.pos end;local aa=self.pos+dir_to_vec(d)if a==1 then if not aa:is_wall()and(not aa:is_water()or self.aquatic)then return aa end end;return self.pos end;function x.attempt_melee(self)if self.life<=0 then return end;attack_point=self:act_pos()h=attack_point:actors_on_here("player")for a in all(h)do if a.life>0 then a.stunned_turns=3 end end end;function x.tick_oxygen(self)if self:in_water()then if self.o2<=0 and self.life>0 then self:hurt(1,true)end;if self.o2>=1 then self.o2=self.o2-1;sfx(12)end else self.o2=self.max_o2 end end;function x.in_water(self)return self.pos:is_water()and self:act_pos():is_water()end;function x.turn_to_face_act(self)if self.act[2]>0 then self.facing=self.act[2]end end;function x.move_type(self)return enemy_variants[self.subpattern][self.variant][1]end;function x.determine_act(self)if self.life<=0 then self.act={a=0,d=0}return end;if self.stunned_turns>0 then self.stunned_turns=self.stunned_turns-1;if self.stunned_turns>0 then return end;ha=self.pos:actors_on_here()if ha and ha[1].life>0 and ha[1]~=self then self.stunned_turns=1;return end end;previous_facing=self.facing;follow_prints=self.pos:objects_on_here("prints","blood_prints")if follow_prints then self.facing=follow_prints[1].facing end;self.act[1]=1;self.act[2]=self.facing;self:determine_facing()tiles=self:tiles_ahead(previous_facing,true)for b,R in pairs(tiles)do if player.pos==R then self.act={2,previous_facing}self.facing=previous_facing;sfx(10)return end end;tiles=self:tiles_ahead(self.facing,true)for b,R in pairs(tiles)do if player.pos==R then self.act[1]=2;sfx(10)return end end;self:turn_to_face_act()end;function x.determine_facing(self)local ab=self:move_type()local apos=self:act_pos()if ab=="clockwise"then local ac=0;while apos==self.pos do local f=self.facing+1;if f>4 then f=5-f end;self.act[2],self.facing=f,f;apos=self:act_pos()ac=ac+1;if ac>4 then self.stunned_turns=3;return end end end;if ab=="still"then self.act={0,0}return end;if ab=="line"then if apos==self.pos then f=self.facing+2;if f>4 then f=abs(5-f)+1 end;self.act[2],self.facing=f,f end end;if ab=="cc"then local ac=0;while apos==self.pos do f=self.facing-1;if f<1 then f=4 end;self.act[2],self.facing=f,f;apos=self:act_pos()ac=ac+1;if ac>4 then self.stunned_turns=3;return end end end end;function x.do_avoidance(self)if self.act[1]>1 then return false end;local ad=self:act_pos()for a in all(global_objects.actor)do if a.life>0 then apos=a:act_pos()if a~=self and apos==ad and a.subpattern~="player"then self.act={0,0}return true end end end;return false end;function x.pickup_prints(self)for a in all(global_objects.actor)do if a.life<=0 and a.pos==self.pos then self.blood_prints=6;return end end end;function x.place_new_prints(self,a8)if self.life<=0 or self.pos:is_water()or self.pos:objects_on_here(nil,"trapdoor")then return end;p=self.pos:objects_on_here("prints",a8)if not p then d=self.act[2]if d<=0 then d=self.facing end;o=make_object(self.pos,{"prints",a8,d},true)add(global_objects.prints,o)add(global_objects.object,o)end end;function x.attempt_act(self,ae)a=self.act[1]if a==1 and ae==1 then self:attempt_move()end;if a==2 and ae==2 then self:attempt_shot()end end;function x.attempt_move(self)self.pos=self:act_pos()end;function x.attempt_shot(self)sfx(4)tiles={}for i,R in pairs(self:tiles_ahead(self.act[2],true))do hurts={}add(tiles,R)as=R:actors_on_here()if as then for a in all(as)do if a and self~=a and a.life>0 then add(hurts,a)end end end;l=#hurts;for a in all(hurts)do if l>1 then if a~=player and a.life>0 then a:hurt()self:queue_lasers(tiles,a)return end elseif l==1 then a:hurt()self:queue_lasers(tiles,a)return end end end end;function x.redirect_existing_prints(self,a8)if self.life<=0 then return end;p=self.pos:objects_on_here("prints",a8)if not p then return end;if self.act[2]>0 then p[1].facing=self.act[2]end end;function x.set_frames(self,pattern,W)self.frames={pattern=pattern,n=W}end;function x.queue_lasers(self,tiles,a,d)d=d or self.act[2]self.laser={frames=2,target=a.pos,dir=d,tiles={}}del(tiles,tiles[#tiles])self.laser.tiles=tiles end;function x.hurt(self,af,ag)af=af or 1;self.life=max(0,self.life-af)if self.life==0 then sfx(5)if not ag then self:set_frames("death",4)end else sfx(5,-1,1,3)if not ag then self:set_frames("hurt",2)end end end;function x.fall(self)self.life=-2;self:set_frames("fall",2)end;function x.tiles_ahead(self,d,ah)ah=ah or false;if d<=0 then d=self.facing end;p=self.pos+dir_to_vec(d)collected={}i=1;while not(p:is_wall()and(not p:is_glass()or not ah))do collected[i]=p;i=i+1;p=p+dir_to_vec(d)end;return collected end;function x.draw_sprite(self)local p=to_pixel(self.pos)local s=self:tile_shift()ssw,ssh,y_shift=8,8,0;if self:in_water()then ssh=4;y_shift=2 end;palswap=enemy_variants[self.subpattern][self.variant][2]pal(palswap[1],palswap[2])zspr(self:sprite(),p.x+s.x*2,p.y+s.y*2+y_shift,2,1,1,ssw,ssh)pal(palswap[1],palswap[1])end;function x.draw_below(self)if self.life>0 then return end;self:draw_sprite()end;function x.draw(self)if self.life<=0 then return end;self:draw_sprite()end;function x.draw_above(self)anim=animations[self.subpattern][7]if self.act[1]==2 or self==player and input_act==5 and turn_start==nil then d=self.act[2]if self==player and input_act==5 then d=input_dir end;if d<=0 then d=self.facing end;s=anim[d]tiles=self:tiles_ahead(d,true)for R in all(tiles)do t=to_pixel(R)zspr(s,t.x,t.y)end end;l=self.laser;s=anim[l.dir]if l.frames>0 then for R in all(l.tiles)do if l.frames==1 then pal(8,2)pal(11,3)end;t=to_pixel(R)l_dir_mod=(l.dir+1)%2;zspr(s,t.x,t.y)zspr(s,t.x+l_dir_mod*2,t.y+(1-l_dir_mod)*2)pal(8,8)pal(11,11)end end end;function x.sprite(self)frames_n=self.frames.n;pattern=self.subpattern;frames_pattern=self.frames.pattern;if frames_n>0 then if frames_pattern=="death"then return animations[pattern][5][4-frames_n+1]end;if frames_pattern=="hurt"then return animations[pattern][5][2-frames_n+1]end;if frames_pattern=="fall"then return animations[pattern][6][2-frames_n+1]end end;if self.life<=0 then if self.life==-2 then return 255 end;return animations[pattern][5][4]end;if self.stunned_turns>0 then return animations[pattern][8][frame%2+1]end;anim=animations[pattern][self.facing]if turn_start~=nil then if self.act[1]==1 then return anim[frame+1]end end;if input_act==6 and self==player and turn_start==nil then return animations[pattern][input_dir][1]end;if input_act==5 and self==player and turn_start==nil then anim=animations[pattern][input_dir]end;if self.act[1]==2 or input_act==5 and self==player and turn_start==nil then return anim[6]end;return default_sprite(pattern,self.facing)end;function x.tile_shift(self)apos=self:act_pos()if not(apos==self.pos)and turn_start then return make_vec2d((apos.x-self.pos.x)*biframe,(apos.y-self.pos.y)*biframe)end;return make_vec2d(0,0)end;n.__index=x;pos_map={{0,1,0,-1},{-1,0,1,0}}function dir_to_vec(ai)return make_vec2d(pos_map[1][ai],pos_map[2][ai])end;function make_vec2d(G,F)local t={x=G,y=F}setmetatable(t,r)return t end;function y.distance_to(self,H)local v=H-self;return sqrt(v.x*v.x+v.y*v.y)end;function y.is_adjacent(self,H)return self.x==H.x+1 and self.y==H.y or self.x==H.x-1 and self.y==H.y or self.x==H.x and self.y==H.y+1 or self.x==H.x and self.y==H.y-1 end;function get_global_objects(pattern,a8)pattern=pattern or a8;local aj={}for o in all(global_objects[pattern])do if not a8 or o.subpattern==a8 then add(aj,o)end end;return aj end;function y.objects_on_here(self,pattern,a8)local aj,ak=get_global_objects(pattern,a8),{}for o in all(aj)do if o.pos==self then add(ak,o)end end;if#ak>0 then return ak end;return nil end;function y.actors_on_here(self,al)al=al or""local Q={}for a in all(global_objects.actor)do if a.pos==self and a.subpattern~=al then add(Q,a)end end;if#Q>0 then return Q end;return nil end;function y.is_glass(self)m=lmapget(self)return m==119 or m==120 end;function y.is_wall(self)a=self:objects_on_here("door")if a and a[1].solid==1 then return true end;m=lmapget(self)return m>=64 and m<=127 end;function y.is_vault_gate(H)m=lmapget(H)return m==70 or m==71 end;function y.is_water(H)return lmapget(H)==182 end;function r.__add(a,am)return make_vec2d(a.x+am.x,a.y+am.y)end;function r.__sub(a,am)return make_vec2d(a.x-am.x,a.y-am.y)end;function r.__eq(a,am)return a.x==am.x and a.y==am.y end;r.__index=y;function check_type(v,t)return type(v)==t end;function copymt(o)local c;if type(o)=='table'then c={}for b,v in pairs(o)do c[b]=copymt(v)end else c=o end;return c end;function concat(an,ao)local ap={}for i=1,#an do ap[i]=an[i]end;for i=1,#ao do ap[#an+i]=ao[i]end;return ap end;function to_pixel(aq)return make_vec2d(aq.x*16,aq.y*16)end;function n_to_vec(W)return make_vec2d(8*(W%16),8*flr(W/16))end
